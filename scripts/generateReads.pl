#!/usr/bin/perl -w

# generate simulated reads for different sequencing technologies 

# 0: Illumina PE: 100 bp read length, 1% error rate, insert size 200-500 bp
# 1: Illumina MPE (mate paired end): 100 bp read length, 1% error, insert 2kb-5kb
# 2: Illumina SE: 100 bp read length, 1% error rate
# 3: PacBio: 3000 read length, 18% error rate

use strict;
use Getopt::Std;

our ($opt_t, $opt_n, $opt_r, $opt_h);
getopt( 'tnrh' );

## Global Var ##
# set option values
my $tech = 0;		# technology code
my $nr = 10000;		# number of reads
my ($ref, $hap);

# assign user defined values
$tech = $opt_t if $opt_t;
$hap = $opt_h if $opt_h;
$nr = $opt_n if $opt_n;

if ($opt_r) {
	$ref = $opt_r;
} else {
	print "USAGE:\n-r\tReference genome in fasta format\n-n\tNumber of reads to be generated (default: 10000 single/20000 paired end)\n";
	print "-t\tTechnology code:\n\t0: Illumina paired end (default)\n\t1: Illumina mate paired end\n\t2: Illumina single end\n\t3: PacBio\n";
	print "-h\tHaplotype file (optional). 1st line contains frequency of reference genome, every other line contains <hap_freq>, <hap_position1>, <hap_base1>, <hap_position2>, ..., separated by tabs. The positions are in ascending order. See tryhaps.txt for example.\n";
	die "\n\n";
}	

my @techname = ("illPE", "illMPE", "illSE", "PacBio");
my @base = ("A", "T", "C", "G");
my @rlen = (100, 100, 100, 3000);	# readlengths for diff technologies, index matches tech code
my @errpcnt = (1, 1, 1, 18);		# percent read error rate for diff tech, index matches tech code
my @rerr;				# number of sites per read that'll have substitution error
for my $i ( 0 .. $#rlen ) {
	$rerr[$i] = int( $errpcnt[$i] * $rlen[$i] / 100 ); 
}

my @ilower = (200, 2000);	# lower and upper bounds for paired end data, index matched tech code
my @iupper = (500, 5000);

## Main ##

my ($reads, $index) = getReads( $ref, $nr, $tech );
introErrors ( $reads, $tech );

#print "\nAfter introducing haps:\n";
if ( $hap ) {
	introHaps ( $reads, $hap, $index, $tech, $ref, $nr );
}
printFastq( $reads, $tech, $ref, $nr );

## End of main ##

###############
# getReads
#
# reads a reference genome, number of reads required
# and seq technology code (that determines read length)
# and returns a reference to a hash where key is fasta header
# for read, and key is read sequence. For paired end reads,
# data str is reference to an array of two hashes, where 
# 1st entry contains reads for one set of ends, 
# and 2nd entry contains reads for the other paired end
#
# USAGE: $reads = getReads( $ref, $num_reads, $seqtech);
###############
sub getReads {
	my ($ref, $nr, $tech) = @_;
	my ($seq, $reads, $index);	# index stores the read ids that map to each pos in genome 
	my (@genome, @ridx);	

	open(FH, $ref) or die "can't open file $ref: $!\n";
	while (<FH>) {
		chomp;
		$seq = $seq . $_ if ($_ =~ /^[a-zA-Z]/); 
	}
	close (FH);
 	@genome = split "", $seq;	

	# generate indices for read start positions
	for my $i ( 0 .. $nr-1 ) {
		push @ridx, int(rand($#genome+1));
	}	
	
	# generate reads from the indices 
	for my $i ( 0 .. $#ridx ) {
		my $rkey = "p0:r" . $i . ":idx" . $ridx[$i];
		my $lidx = $ridx[$i]+$rlen[$tech];
		$lidx = $#genome if $#genome < $lidx;
		$reads->[0]->{$rkey} = [ @genome[ $ridx[$i] .. $lidx ] ];
		for my $rpos ( $ridx[$i] .. $lidx ) {
			push @{ $index->[$rpos] }, $rkey;
		}
	}
	
	# generate paired end reads if required
	if ( $tech < 2 ) {
		# generate insert sizes for each paired end read
		my $isdiff = $iupper[$tech] - $ilower[$tech];
		for my $i ( 0 .. $#ridx ) {
			my $isize = int(rand($isdiff)) + $ilower[$tech];
			my $pidx = $ridx[$i] + $rlen[$tech] + $isize;
			my $prkey = "p1:r" . $i . ":idx" . $pidx;
#			print "read: $i\tridx: $ridx[$i]\tpridx: $pidx\n";
			my $lidx = $pidx+$rlen[$tech];
			$lidx = $#genome if $lidx > $#genome;
			$reads->[1]->{$prkey} = [ @genome[ $pidx .. $lidx ] ];
#			print "$i :: ridx: $ridx[$i], isize: $isize, pidx: $pidx\n";
			for my $rpos ( $pidx .. $lidx ) {
				push @{ $index->[$rpos] }, $prkey;
			}
		}		
	}
	return ($reads, $index);
}
# End of getReads #

###################
# introErrors
#
# input: reads generated by getReads
# output: reads with introduced errors
#
# USAGE: introErros( $reads, $tech );
###################
sub introErrors {
	my ($reads, $tech) = @_;
	
	for my $r ( 0 .. $#{ $reads } ) {
		foreach my $k ( keys %{ $reads->[$r] } ) {
			for my $nerr ( 0 .. $rerr[$tech]-1 ) {
				my $epos = int(rand( $rlen[$tech]+1 ));	# position with error
				if ( $reads->[$r]->{$k}->[$epos] ) {
					my $ebase = $base[ int(rand(4)) ];
#					print "key:$k, rlen:$rlen[$tech], epos:$epos, orig base: $reads->[$r]->{$k}->[$epos], ";
					$reads->[$r]->{$k}->[$epos] = $ebase;
#					print "mutbase: $ebase\n";
				}
			}
		}
	}
}
# End of introErrors #

##################
# printFastq
#
# prints the reads in fastq format. Paired
# end reads are printed in two different files
# with suffixes <>_fir.fastq and <>_sec.fastq
#
# USAGE: printFastq( $reads, $tech );
###################
sub printFastq {
	my ($reads, $tech, $seqfile, $nr) = @_;
	my $fname = $seqfile . "_sim_" . $techname[$tech] . "_rlen" . $rlen[$tech] . "_erate" . $errpcnt[$tech] . "_nr" . $nr;	
	$fname = $fname . "_insert" . $ilower[$tech] . "to" . $iupper[$tech] if $tech < 2;
	my @suffix = ("_fir.fastq", "_sec.fastq");

	for my $i ( 0 .. $#{ $reads } ) {
		open( FH, ">$fname$suffix[$i]" ) or die "can't open file to write: $!\n";
		for my $key ( keys %{ $reads->[$i] } ) {
			next if $#{ $reads->[$i]->{$key} } == -1;  # read is of length 0, happens with paired end reads
			print FH "@ $key\n";
			print FH @{ $reads->[$i]->{$key} };
			my $rqual = ".";			# read quality string
			for my $pos ( 0 .. $#{ $reads->[$i]->{$key} }-1 ) {
				$rqual = $rqual . ".";
			}
			print FH "\n+\n$rqual\n";
		}
		close FH;
	}
}
# End of printFastq #

####################
# introHaps
#
# reads in a file containing haplotypes and their
# respective frequencies and intoduces those 
# haplotypes in the reads
#
# USAGE: introHaps( $reads, $hapfile, $index, $tech, $seqfile );
####################
sub introHaps {
	my ($reads, $hapfile, $index, $tech, $seqfile, $nr) = @_;
	my $haps;	# reference to hash of hashes: hapfreq => {hap_pos => hap_base}
	
	# if argument $seqfile is passed, print reads that map to each hap position if argument
	
	if ( $seqfile ) {
		my $filename = $seqfile . "_$techname[$tech]_nr" . $nr . ".hapread";
		open (FH, ">$filename" ) or die "can't open file to write: $!\n";
	}		

	# store haps in $haps, 1st value is the hap frequency
	open( HAP, $hapfile ) or die "can't open file $hapfile: $!\n";
	while ( <HAP> ) {
		if ($_ =~ /.+\t\d+/) {
			my $htrack;  	# reference to store read-keys that map at a hap position
			print FH "haplotype: $_" if $seqfile;
			chomp;
			my @haplotypes = split /\t/;
			my %hap = @haplotypes[ 1 .. $#haplotypes ];   # keys are hap positions, values are hap bases
			my @happos = keys %hap;		        	# contains only the haplotype positions

			for my $i ( 0 .. $#happos ) {
				# determine number of reads to insert haplotype base into
				next if $#{ $index->[ $happos[$i] ] } < 0;	# no reads map to this position
				
				my $nreads = $#{ $htrack->{ $happos[$i] } } + 1; 	# #reads having this hap base already
				my $nhap = int($haplotypes[0] * $#{ $index->[ $happos[$i] ] }); # $haplotypes[0] = haplotype frequency
				if ($nreads >= 1) {
					$nhap = $nhap - $nreads;
				}
				next if $nhap <= 0;		# no need to generate haplotypes
			#	print "#reads at $happos[$i]: $#{ $index->[$happos[$i]] }+1\tnum hap reads: $nhap+1\n";

				for my $rh ( 0 .. $nhap ) {
					# randomly pick a read that covers this position to insert haplotype into
					my $hidx = int(rand( $#{$index->[$happos[$i]]}+1 ));
					my $rkey = $index->[ $happos[$i] ]->[$hidx];  	# read key for the randomly chosen read
					push @{ $htrack->{ $happos[$i] } }, $rkey;
			#		print "pos: $happos[$i]\trkey:$rkey\n";
	
					next if $i == $#happos;
					# check if this read also covers next positions for this haplotype
					for my $j ( $i+1 .. $#happos ) {
						for my $nkey ( @{ $index->[ $happos[$j] ] } ) {
							if ($nkey eq $rkey) {
								push @{ $htrack->{ $happos[$j] } }, $nkey;
								print FH "Same read: $rkey\tpositions $happos[$i], $happos[$j]\n" if $seqfile;
							}
						}
					}

					# if paired-end reads are generated, check if the paired read contains any of next hap positions
					if ( $tech < 2 and $rkey =~ /^p0\:r/ ) {
						my @key = split /:/, $rkey;
						my $pairedkey = "p1:" . $key[1] . ":";
	
						for my $j ( $i+1 .. $#happos ) {
							for my $hkey ( @{ $index->[ $happos[$j] ]} ) {
								if ($hkey =~ /$pairedkey/ ) {
									push @{ $htrack->{ $happos[$j] } }, $hkey;
									print FH "Paired read $key[1]: $happos[$i] in $rkey, $happos[$j] in $hkey\n" if $seqfile;
								}
							}
						}
					}	
				}
			}

			# insert haplotypes
			for my $pos ( @happos ) {
				print FH "\n$pos:" if $seqfile;
				for my $hapread ( @{ $htrack->{ $pos } } ) {
					print FH "$hapread\t" if $seqfile;
					if ( $hapread =~ /p0.+idx(\d+)$/ ) {
						$reads->[0]->{$hapread}->[$pos-$1] = $hap{$pos};	#$pos: seqpos, $1:read start position
					} elsif ( $hapread =~ /p1.+idx(\d+)$/ ) {
						$reads->[1]->{$hapread}->[$pos-$1] = $hap{$pos};
					}
				}
			}
		}
	}
	close HAP;
	close FH;
	return $reads;
}
# End of introHaps #
